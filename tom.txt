                                                      Practical 1
                          Sorting techniques: Bubble sort, Selection sort, Insertion, Shell sort , Quick Sort, Merge sort
 
code for Bubble Sort:

package Bubble_sort;
import java.util.Scanner;
public class Sort {
static void Sort(int[] a, int n) {
System.out.println("roll no: 35");
int i, j, minIndex, temp;
for (i = 0; i < n - 1; i++) {
minIndex = i;
for (j = i + 1; j < n; j++) {
if (a[j] < a[minIndex]) {
minIndex = j;
}
}
temp = a[minIndex];
a[minIndex] = a[i];
a[i] = temp;
}
System.out.println("Array after Selection
Sort:");
for (i = 0; i < n; i++) {
System.out.print(a[i] + " ");
}
}
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
System.out.println("Roll no: 193\nEnter
array size:");
int n = sc.nextInt();
int[] a = new int[n];
System.out.println("Enter array
elements:");
for (int i = 0; i < n; i++) {
a[i] = sc.nextInt();
}
Sort(a, n);
sc.close();
}
}



Code for Insertion Sort : -


import java.util.Arrays;
import java.util.Scanner;
public class Sort {
static void Sort(int[] a,int n) {
int k,PTR,i,temp;
for(i=1;i<=n-1;i++) {
temp=a[i];
PTR=i-1;
while(PTR>=0 && temp<a[PTR]) {
a[PTR+1]=temp;
}
a[PTR+1]=temp;
}
System.out.println("Array after Insertion
Sort");
for (i=0;i<n;i++) {
System.out.print(a[i]+" ");
}
}public static void main(String[] args) {
// TODO Auto-generated method stub
Scanner sc=new Scanner(System.in);
int a[]=new int[10];
int n,i;
System.out.println("Roll no:35\nEnter
array size");
n=sc.nextInt();
System.out.println("Enter array element
");
for(i=0;i<n;i++) {
a[i]=sc.nextInt();
}
Sort(a,n); //sorting array element using
insertion sort
sc.close();
}
}



Code for Selection Sort : -


import java.util.Arrays;
import java.util.Scanner;
public class SelectionSort {
static int[] selectionSort(int[] arr,int size) {
for (int i = 0; i <= size -2; i ++) {
int minIndex = i;
for (int j = i + 1;j <= size - 1; j++) {
if (arr[minIndex] > arr[j]) {
minIndex = j;
}
if(minIndex != i) {
int temp = arr[i];
arr[i] = arr[minIndex];
arr[minIndex] = temp;
}
}
}
return arr;
}
public static void main(String[] args) {
Scanner input = new Scanner(System.in);
System.out.print("Enter Size: ");
int size = input.nextInt();
int arr[] = new int[size];
System.out.print("Enter Array elements: ");
for (int i = 0; i < size; i++) {
arr[i] = input.nextInt();
}
selectionSort(arr, size);
System.out.print("Selection Sort: " + Arrays.toString(arr));
System.out.println("35");
input.close();
}
}



Code for Shell Sort :-

package prac;
public class shell_sort {
public static void shellSort(int[] arrayToSort) {
int n = arrayToSort.length;
for (int gap = n / 2; gap > 0; gap /= 2) {
for (int i = gap; i < n; i++) {
int key = arrayToSort[i];
int j = i;
while (j >= gap && arrayToSort[j - gap] > key)
{
arrayToSort[j] = arrayToSort[j - gap];
j -= gap;
}
arrayToSort[j] = key;
}
}
}
public static void printArray(int[] arr) {
for (int num : arr) {
System.out.print(num + " ");
}
System.out.println();
}
public static void main(String[] args) {
System.out.println("Roll no. :- 35");
int[] data = {64, 34, 25, 12, 22, 11, 90};
System.out.println("Original Array:");
printArray(data);
shellSort(data);
System.out.println("Sorted Array:");
printArray(data);
}
}


Code for Quick Sort : -

package prac;
public class quick_sort {
public static void quickSort(int arr[], int begin, int end) {
if (begin < end) {
int partitionIndex = partition(arr, begin, end);
quickSort(arr, begin, partitionIndex-1);
quickSort(arr, partitionIndex+1, end);
}
}
private static int partition(int arr[], int begin, int end) {
int pivot = arr[end];
int i = (begin-1);
for (int j = begin; j < end; j++) {
if (arr[j] <= pivot) {
i++;
int swapTemp = arr[i];
arr[i] = arr[j];
arr[j] = swapTemp;
}
}
int swapTemp = arr[i+1];
arr[i+1] = arr[end];
arr[end] = swapTemp;
return i+1;
}
public static void printArray(int[] arr) {
for (int num : arr) {
    System.out.print(num + " ");
}
System.out.println();
}
public static void main(String[] args) {
System.out.println("Roll no. :- 35");
int[] data = {64, 34, 25, 12, 22, 11, 90};
System.out.println("Original Array:");
printArray(data);
quickSort(data, 0, data.length - 1);
System.out.println("Sorted Array:");
printArray(data);
}
}


Code for Merge Sort : -


package MergeSort;
import java.util.Scanner;
public class MergeSort {
public static void mergeSort(int[] a, int low, int
mid, int high) {
int h = low;
int i = low;
int j = mid + 1;
int[] b = new int[a.length];
while ((h <= mid) && (j <= high)) {
if (a[h] <= a[j]) {
b[i] = a[h];
h++;
} else {
b[i] = a[j];
j++;
}
i++;
}
if (h > mid) {
for (int k = j; k <= high; k++) {
b[i] = a[k];
i++;
}
} else {
for (int k = h; k <= mid; k++) {
b[i] = a[k];
i++;
}
}
for (int k = low; k <= high; k++) {
a[k] = b[k];
}
}
public static void Sort(int[] a, int low, int high)
{
if (low < high) {
int mid = (low + high) / 2;
Sort(a, low, mid);
Sort(a, mid + 1, high);
mergeSort(a, low, mid, high);
}
}
public static void main(String[] args) {
System.out.println(" Roll no.: 35");
Scanner sc = new Scanner(System.in);
System.out.println("Enter array size");
int n = sc.nextInt();
int[] a = new int[n];
System.out.println("Enter array element:");
for (int i = 0; i < n; i++) {
a[i] = sc.nextInt();
}
System.out.println("Array element before
sort:");
for (int i = 0; i < n; i++) {
System.out.print(a[i] + " ");
}
System.out.println();
Sort(a, 0, n - 1);
System.out.println("Array element after sort:");
for (int i = 0; i < n; i++) {
System.out.print(a[i] + " ");
}
System.out.println();
sc.close();
}
}
                                                    practical 2
                                          Searching - Linear and Binary Search
                                        
  Code for Linear search : -


package searchdemolinear;
import java.util.Scanner;
public class Linear {
public static void main(String[] args) {
System.out.println("35");
Scanner sc= new Scanner(System.in);
int i,key, f=0,a[];
System.out.println("Enter The Number of elements");
int n = sc.nextInt();
a = new int[n];
System.out.println("enter the array element");
for(i=0; i<n; i++) {
a[i] = sc.nextInt();
}
System.out.println("enter the value to find");
key=sc.nextInt();
for(i=0; i<n; i++) {
if(a[i]==key) {
f=1;
break;
}
}
if(f==1) {
System.out.println("element found at" +(i+1));
} else {
System.out.println("element not found");
}
}
}



  Code for Binary search : -


  Code :-
package searchdemolinear;
import java.util.Scanner;
public class BinarySearch {
public static void BinarySearch(int a[], int low, int high, int key) {
while (low<=high) {
int mid = (low+high)/2;
if(key==a[mid]) {
System.out.println("Element is found at index;" +(mid+1));
break;
}
else
if (key<a[mid])
high=mid-1;
else
low=mid+1;
}
if(low>high)
System.out.println("element is not found");
}
public static void main(String[] args) {
System.out.println("35");
Scanner sc= new Scanner(System.in);
int i,key, f=0,a[], low, high;
System.out.println("Enter The Number of elements");
int n = sc.nextInt();
a = new int[n];
System.out.println("enter the array element");
for(i=0; i<n; i++) {
a[i] = sc.nextInt();
}
System.out.println("enter the value to find");
key=sc.nextInt();
low=0;
high=n-1;
BinarySearch(a,low,high,key);
}
}



                                                         practical 3
                                                   3. Linear and circular queue 

  Code for linear queue using array : -


package queuedemo;
import java.util.Scanner;
public class Circularqueue {
int[] arr;
int front, rear, item;
final int MAX;
public Circularqueue() {
MAX = 5;
arr = new int[MAX];
front = rear = -1;
}
public void enqueue() {
if (((rear == MAX - 1) && (front == 0)) || (rear + 1 == front)) {
System.out.println("\nCircular queue is full!");
return;
}
if (rear == MAX - 1)
rear = 0;
else
rear++;
Scanner sc = new Scanner(System.in);
System.out.print("\nEnter element to be inserted in circular
queue: ");
item = sc.nextInt();
arr[rear] = item;
if (front == -1)
front = 0;
}
public void dequeue() {
if (front == -1) {
System.out.println("\nCircular queue is empty!");
return;
}
System.out.println("\nElement to be deleted from circular queue:
" + arr[front]);arr[front] = 0;
if (front == rear) {
front = rear = -1;
} else {
if (front == MAX - 1)
front = 0;
else
front++;
}
}
public void display() {
if (front == -1) {
System.out.println("\n Circular queue is empty!");
} else {
System.out.println("\n elements are:");
if (front <= rear) {
for (int i = front; i <= rear; i++) {
System.out.print(arr[i] + "\t");
}
} else {
for (int i = front; i < MAX; i++) {
System.out.print(arr[i] + "\t");
}
for (int i = 0; i <= rear; i++) {
System.out.print(arr[i] + "\t");
}
}
System.out.println();
}
}
public void count() {
int c=0;
if (front==-1) {
System.out.println("\n Circular queue is empty!");
}else {
if (front <=rear) {
for(int i = front; i<=rear; i++) {
c++;
}
System.out.println("\n No of element in queue are
"+c);
}
}
}
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
System.out.println("Neelam | Batch: D | 231 ");
Circularqueue obj = new Circularqueue();
int choice;
do {
System.out.println("\n1.Add 2.Delete 3.Display 4.count 5.Exit");
System.out.print("Enter choice: ");
choice = sc.nextInt();
switch (choice) {
case 1:
obj.enqueue();
break;
case 2:
obj.dequeue();
break;
case 3:
obj.display();
break;
case 4:
obj.count();
break;
case 5:
System.out.println("Exiting...");
System.exit(0);
break;
}
} while (choice != 5);
sc.close();
}
}





Code for  circular queue using array: -

import java.util.Scanner;
public class CircularQueue {
int[] arr;
int front,rear,item;
final int MAX;
public CircularQueue()
{
MAX = 5;
arr = new int[MAX]
front = rear = -1;
}
public void insert()
{
if(((rear == MAX - 1) && (front == 0)) || (rear + 1 == front))
{
System.out.println("\n Circular Queue is Full! ");
}
if(rear == MAX -1)
{
rear = 0;
}
else
{
rear ++;
}
Scanner sc = new Scanner(System.in);
System.out.println("\n Enter Elements to be inserted in Circular Queue: ");
item = sc.nextInt();
arr[rear] = item;
if(front == -1)
{
front = 0;
}
}
public void dequeue()
{
if(front == -1)
{
System.out.println("\n Circular Queue is Empty! ");
return;
}
System.out.println("Element to be deleted from the Circular Queue: ");
arr[front] = 0;
if(front == rear)
{
front = rear = -1;
}
else
{
if(front == MAX -1)
{
front = 0;
}
else
{
front ++;
}
}
}
public void display()
{
if(front == -1)
{
System.out.println("\n Circular Queue is Empty! ");
}else
{
System.out.println("\n Elements are: ");
if(front <= rear)
{
for(int i=front ; i <= rear ; i++)
{
System.out.println(arr[i] + "\t");
}
}
}
}
public void Count()
{
int count= 0;
if(front == -1)
{
System.out.println("Circular queue is Empty! ");
return;
}
else
{
for(int i=front ; i <= rear ; i++)
{
count ++;
}
System.out.println("Element in Circular Queue are : " + count);
}
}public static void main(String[] args)
{
Scanner sc = new Scanner(System.in);
System.out.println("Roll Number : 57 ");
CircularQueue q = new CircularQueue();
int ch;
do
{
System.out.println("\n 1:Insert 2:Dequeue 3:Count 4:Display 5:Exit");
System.out.println("Enter Choice:");
ch = sc.nextInt();
switch(ch)
{
case 1:
q.insert();
break;
case 2:
q.dequeue();
break;
case 3:
q.Count();
break;
case 4:
q.display();
break;
case 5:
System.out.println("Exiting Program!");
break;
}
}while(ch!=5);
sc.close();
}
}



                                                  practical 4
              Satck Opeartions and Application of Satck : Balancing of parenthesis , Evaluation of postfix expression

code for Postfix Expressions Evaluation : -

import java.util.Scanner;
public class postFixeEvaluation {
    private int top;
private int[] s = new int[10];
public postFixeEvaluation() {
top = -1;
}
public void push(int x) {
if (top ==s.length -1) {
System.out.println("Stack Overflow");
}
else {
top++;
s[top]=x;
}
}
public int pop() {
if(top ==-1) {
System.out.println("Stack underflow");
return 0;
}
else {
int x =s[top];
top=top-1;
return x;
}
}
public int evaluate (char operator, int op1, int op2) {
switch(operator) {
case '+':
return op1+op2;
case '-':
return op1-op2;
case '*':
return op1*op2;
case'/':
if (op2 == 0) {
System.out.println("Error: Division by Zero occur /0");
return 0;
}
return op1/ op2;
case '%':
return op1 % op2;
default :
System.out.println("Invalid operator found: "+operator);
return 0;
}
}
public static void main(String[] args) {
postFixeEvaluation obj = new postFixeEvaluation();
Scanner sc = new Scanner(System.in);
System.out.print("Enter the expression that you want to perform (e.g., 65+ for
5+6: ):");
String expression = sc.nextLine();
for(int i=0; i< expression.length(); i++) {
char ch= expression.charAt(i);
if(Character.isDigit(ch)) {
obj.push(ch - '0');
}
else {
int op2 = obj.pop();
int op1 =obj.pop();
int result = obj.evaluate(ch, op1, op2);
obj.push(result);
}
}
int finalValue = obj.pop();
System.out.println("Value of the given expression " + expression + " is
:"+finalValue);
sc.close();
}
}



code for  Balancing Parenthesis : -


import java.util.Scanner;
public class BalanceParanthsis {
int top;
char[] s = new char[20];
public BalanceParanthsis(){
top=-1;
}
public void push(char c) {
top=top+1;
s[top] = c;
}
public char pop() {
char x =s[top];
top=top-1;
return x;
}
public static void main(String[] args) {
// TODO Auto-generated method stub
Scanner sc = new Scanner(System.in);
BalanceParanthsis d = new BalanceParanthsis();
char a;
String exp;
System.out.print("Enter String expresssion including prenthesis,square bracket, curly
braces: ");
exp = sc.nextLine();
for(int i=0; i<exp.length(); i++) {
char ch = exp.charAt(i);
if(ch == '(' || ch == '[' || ch == '{') {
d.push(ch);
}
else {
switch(ch) {
    case ')':
a = d.pop();
if (a == '{' || a == '[') {
System.out.println("Expression is not having balanced parenthesis.");
sc.close();
return;
}
break;
case ']':
a = d.pop();
if (a == '{' || a == '(') {
System.out.println("Expression "+ exp +" is not having balanced parenthesis.");
sc.close();
return;
}
break;
case '}':
a = d.pop();
if (a == '(' || a == '[') {
System.out.println("Expression "+ exp +" is not having balanced parenthesis."); sc.close();
return;
}
break;
}
}
}
if(d.top==-1) {
System.out.println("Expression "+ exp +" is having balanced parenthesis.");
}
else {
System.out.println("Expression "+ exp +" is not having balanced parenthesis.");
}
sc.close();
}
}
